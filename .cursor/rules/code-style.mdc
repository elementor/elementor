---
alwaysApply: true
---
Clean & Minimal React + TypeScript

Core Principles

Minimal change first: Prefer the smallest possible change that solves the problem.

Clarity over cleverness: Readability and intent are more important than brevity.

Architecture-aware: Respect existing boundaries, layers, and responsibilities.

No hacks: Avoid brittle or implicit behavior.

Change Strategy

Do not refactor unrelated code.

Avoid reshaping public APIs unless strictly necessary.

Preserve existing patterns and conventions already used in the codebase.

Prefer extending existing abstractions over introducing new ones.

React Rules

Function components only.

Keep components small and focused (single responsibility).

Prefer composition over configuration.

Lift state only when clearly justified.

Hooks

No useEffect unless required for:

External side effects (subscriptions, DOM, network, timers)

Syncing with non-React systems

Never use useEffect to derive state.

Prefer:

Direct computation

Custom hooks

Controlled props

Timing

**No setTimeout / **setInterval

Exceptions:

Debouncing / throttling

Explicit time-based behavior (animations, delays)

State Management

Avoid duplicated or derived state.

State should model facts, not UI artifacts when possible.

Use reducers only for:

Complex state transitions

Explicit state machines

TypeScript Rules

Prefer explicit types at module boundaries.

Avoid any and unsafe assertions.

Let TypeScript infer types inside functions.

Model domain concepts with:

Discriminated unions

Branded / nominal types when helpful

Architecture & Design Patterns

Respect layer boundaries (UI / domain / data).

UI components should not contain business logic.

Business logic belongs in:

Hooks

Services

Domain utilities

Patterns to Prefer

Composition

Dependency injection via props

Custom hooks as reusable logic units

Pure functions

Patterns to Avoid

God components

Hidden side effects

Tight coupling between UI and data fetching

Effects & Data Fetching

Fetch data outside of render logic.

Prefer:

Dedicated hooks

Data libraries already used in the project

Handle loading and error states explicitly.

Performance

Do not optimize prematurely.

Memoization (useMemo, useCallback) only when:

There is a proven performance issue

Referential stability is required

Code Style

Prefer early returns.

Avoid deeply nested conditionals.

Keep files short and cohesive.

Name things by what they represent, not how they work.

Use early return never write "else" only if must

Before Writing Code

Ask:

Can this be done with fewer changes?

Does this respect the existing architecture?

Is there a simpler, more explicit solution?

Is a hook/effect truly necessary?

If the answer is no â€” rethink the approach.---
alwaysApply: true
---
