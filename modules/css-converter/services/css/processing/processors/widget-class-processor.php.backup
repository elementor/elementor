<?php
namespace Elementor\Modules\CssConverter\Services\Css\Processing\Processors;

use Elementor\Modules\CssConverter\Services\Css\Processing\Contracts\Css_Processor_Interface;
use Elementor\Modules\CssConverter\Services\Css\Processing\Contracts\Css_Processing_Context;

if ( ! defined( 'ABSPATH' ) ) {
	exit;
}

/**
 * Widget Class Processor
 *
 * Handles CSS classes that start with widget-specific prefixes like 'elementor-'
 * These classes contain specific styling that should be applied directly to widgets
 * instead of being processed as global classes.
 */
class Widget_Class_Processor implements Css_Processor_Interface {

	private const WIDGET_CLASS_PREFIX = 'elementor-';

	public function get_processor_name(): string {
		return 'widget_class';
	}

	public function get_priority(): int {
		return 11; // Very early: Before reset styles processor to prevent widget classes from being treated as reset styles
	}

	public function supports_context( Css_Processing_Context $context ): bool {
		$css_rules = $context->get_metadata( 'css_rules', [] );
		$widgets = $context->get_widgets();
		return ! empty( $css_rules ) && ! empty( $widgets );
	}

	public function process( Css_Processing_Context $context ): Css_Processing_Context {
		$css_rules = $context->get_metadata( 'css_rules', [] );
		$widgets = $context->get_widgets();

		if ( empty( $css_rules ) || empty( $widgets ) ) {
			return $context;
		}

		$widget_classes = $this->extract_widget_classes_from_widgets( $widgets );
		$widget_specific_rules = $this->extract_widget_specific_rules( $css_rules, $widget_classes );

		if ( empty( $widget_specific_rules ) ) {
			return $context;
		}

		// Apply widget-specific styles directly to widgets
		$styles_applied = $this->apply_widget_specific_styles( $widget_specific_rules, $widgets, $context );

		// Remove processed rules from css_rules so they don't get processed as global classes
		$remaining_rules = $this->remove_processed_rules( $css_rules, $widget_specific_rules );
		$context->set_metadata( 'css_rules', $remaining_rules );

		// Pass widget classes to HTML Class Modifier for removal from HTML
		$css_class_modifiers = $context->get_metadata( 'css_class_modifiers', [] );
		$css_class_modifiers[] = [
			'type' => 'widget-classes',
			'mappings' => $widget_classes,
		];
		$context->set_metadata( 'css_class_modifiers', $css_class_modifiers );

		// DEBUG: Log what widget classes we're passing for removal
		file_put_contents( '/tmp/widget_classes_for_removal.log', "Widget classes for removal: " . implode( ', ', $widget_classes ) . "\n", FILE_APPEND );

		// Add statistics
		$context->add_statistic( 'widget_specific_rules_found', count( $widget_specific_rules ) );
		$context->add_statistic( 'widget_classes_processed', count( $widget_classes ) );
		$context->add_statistic( 'widget_styles_applied', $styles_applied );

		error_log( 'CSS PIPELINE DEBUG [WIDGET_CLASS]: Applied ' . $styles_applied . ' widget-specific styles from ' . count( $widget_specific_rules ) . ' rules' );
		error_log( 'CSS PIPELINE DEBUG [WIDGET_CLASS]: Passing ' . count( $widget_classes ) . ' widget classes for HTML removal: ' . implode( ', ', array_slice( $widget_classes, 0, 5 ) ) );

		return $context;
	}

	public function get_statistics_keys(): array {
		return [
			'widget_specific_rules_found',
			'widget_classes_processed',
			'widget_styles_applied',
		];
	}

	private function extract_widget_classes_from_widgets( array $widgets ): array {
		$widget_classes = [];
		$this->recursively_extract_widget_classes( $widgets, $widget_classes );
		return array_unique( $widget_classes );
	}

	private function recursively_extract_widget_classes( array $widgets, array &$widget_classes ): void {
		foreach ( $widgets as $widget ) {
			$classes_string = $widget['attributes']['class'] ?? '';
			if ( ! empty( $classes_string ) ) {
				$classes_array = explode( ' ', $classes_string );
				foreach ( $classes_array as $class_name ) {
					$class_name = trim( $class_name );
					if ( $this->is_widget_class( $class_name ) ) {
						$widget_classes[] = $class_name;
					}
				}
			}

			if ( ! empty( $widget['children'] ) ) {
				$this->recursively_extract_widget_classes( $widget['children'], $widget_classes );
			}
		}
	}

	private function is_widget_class( string $class_name ): bool {
		return 0 === strpos( $class_name, self::WIDGET_CLASS_PREFIX );
	}

	private function is_descendant_selector( string $selector ): bool {
		$trimmed = trim( $selector );
		
		// Check for any CSS combinators or complex selectors:
		// - Space (descendant): ".parent .child"
		// - > (child): ".parent>.child"  
		// - + (adjacent sibling): ".prev+.next"
		// - ~ (general sibling): ".prev~.next"
		// - Pseudo-classes: ":not()", ":has()", ":last-child", etc.
		// - Multiple parts separated by combinators
		
		// Split by spaces first
		$space_parts = preg_split( '/\s+/', $trimmed );
		if ( count( $space_parts ) > 1 ) {
			return true; // Has descendant combinator
		}
		
		// Check for other combinators (>, +, ~)
		if ( preg_match( '/[>+~]/', $trimmed ) ) {
			return true; // Has child, adjacent, or sibling combinator
		}
		
		// Check for pseudo-classes that make it complex
		if ( preg_match( '/:(?:not|has|last-child|first-child|nth-child|where|is)\(/', $trimmed ) ) {
			return true; // Has complex pseudo-classes
		}
		
		return false; // Simple selector
	}

	private function is_generic_widget_selector( string $selector ): bool {
		$trimmed = trim( $selector );
		
		// Generic selectors that apply to ALL widgets/elements (should be skipped):
		$generic_patterns = [
			'/^\.elementor-element$/',                    // .elementor-element
			'/^\.elementor-widget$/',                     // .elementor-widget  
			'/^\.elementor-widget\)$/',                   // .elementor-widget) (malformed)
			'/^\.elementor-widget-[a-z-]+$/',            // .elementor-widget-text-editor
			'/^\.elementor-element\.elementor-[a-z-]+$/', // .elementor-element.elementor-absolute
		];
		
		foreach ( $generic_patterns as $pattern ) {
			if ( preg_match( $pattern, $trimmed ) ) {
				return true;
			}
		}
		
		return false;
	}

	private function is_malformed_selector( string $selector ): bool {
		$trimmed = trim( $selector );
		
		// Check for malformed selectors:
		// - Unmatched parentheses
		// - Invalid characters
		// - Empty selectors
		
		if ( empty( $trimmed ) ) {
			return true;
		}
		
		// Check for unmatched closing parentheses
		if ( preg_match( '/\)[^(]*$/', $trimmed ) && ! preg_match( '/\([^)]*\)/', $trimmed ) ) {
			return true;
		}
		
		return false;
	}

	private function extract_widget_specific_rules( array $css_rules, array $widget_classes ): array {
		$widget_rules = [];

		foreach ( $css_rules as $rule ) {
			$selector = $rule['selector'] ?? '';
			
			// CRITICAL: Only process selectors where widget class is the FINAL target
			// Skip descendant selectors like ".elementor-element .elementor-heading-title"
			if ( $this->is_descendant_selector( $selector ) ) {
				continue;
			}
			
			// CRITICAL: Only process SPECIFIC widget selectors, not generic ones
			// Skip generic selectors like ".elementor-element", ".elementor-widget"
			if ( $this->is_generic_widget_selector( $selector ) ) {
				continue;
			}
			
			// Check if this rule targets any of our widget classes
			foreach ( $widget_classes as $widget_class ) {
				if ( $this->selector_targets_class( $selector, $widget_class ) ) {
					$widget_rules[] = [
						'selector' => $selector,
						'properties' => $rule['properties'] ?? [],
						'target_class' => $widget_class,
						'specificity' => $this->calculate_selector_specificity( $selector ),
					];
					break; // Don't duplicate the same rule for multiple classes
				}
			}
		}

		return $widget_rules;
	}

	private function selector_targets_class( string $selector, string $class_name ): bool {
		// Handle complex selectors with combinators and pseudo-classes
		// Examples:
		// .elementor-element .elementor-widget-container -> targets elementor-element
		// .elementor-widget-wrap>.elementor-element -> targets elementor-element  
		// .elementor-element:not(:has(.elementor-widget-container)) -> targets elementor-element
		
		// Extract all class names from the selector using regex
		preg_match_all( '/\.([a-zA-Z0-9_-]+)/', $selector, $matches );
		
		if ( empty( $matches[1] ) ) {
			return false;
		}
		
		$selector_classes = $matches[1];
		
		// Check if our target class is among the extracted classes
		return in_array( $class_name, $selector_classes, true );
	}

	private function calculate_selector_specificity( string $selector ): int {
		// Simple specificity calculation
		$id_count = substr_count( $selector, '#' );
		$class_count = substr_count( $selector, '.' );
		$element_count = preg_match_all( '/\b[a-z]+\b/', $selector );
		// CSS specificity: IDs worth 100, classes worth 10, elements worth 1
		return ( $id_count * 100 ) + ( $class_count * 10 ) + $element_count;
	}

	private function apply_widget_specific_styles( array $widget_rules, array $widgets, Css_Processing_Context $context ): int {
		$unified_style_manager = $context->get_metadata( 'unified_style_manager' );

		if ( ! $unified_style_manager ) {
			$unified_style_manager = new \Elementor\Modules\CssConverter\Services\Css\Processing\Unified_Style_Manager(
				new \Elementor\Modules\CssConverter\Services\Css\Processing\Css_Specificity_Calculator(),
				new \Elementor\Modules\CssConverter\Services\Css\Processing\Css_Property_Conversion_Service()
			);
			$context->set_metadata( 'unified_style_manager', $unified_style_manager );
		}

		$property_conversion_service = new \Elementor\Modules\CssConverter\Services\Css\Processing\Css_Property_Conversion_Service();
		$styles_applied = 0;

		foreach ( $widget_rules as $rule ) {
			$selector = $rule['selector'];
			$properties = $rule['properties'];
			$target_class = $rule['target_class'];

			// Find widgets that have this specific class
			$matching_widgets = $this->find_widgets_with_specific_class( $target_class, $widgets );

			if ( ! empty( $matching_widgets ) ) {
				// FIXED: Convert CSS properties to atomic format BEFORE passing to unified_style_manager
				$converted_properties = $this->convert_properties_to_atomic( $properties, $property_conversion_service );
				
				// DEBUG: Log ALL rules being applied to widgets
				file_put_contents( '/tmp/widget_rules_applied.log', "APPLYING RULE: {$selector}\n", FILE_APPEND );
				file_put_contents( '/tmp/widget_rules_applied.log', "  Target class: {$target_class}\n", FILE_APPEND );
				file_put_contents( '/tmp/widget_rules_applied.log', "  Properties: " . count( $converted_properties ) . "\n", FILE_APPEND );
				foreach ( $converted_properties as $prop_data ) {
					$prop = $prop_data['property'] ?? '';
					$value = $prop_data['original_value'] ?? 'unknown';
					file_put_contents( '/tmp/widget_rules_applied.log', "    {$prop}: {$value}\n", FILE_APPEND );
				}
				file_put_contents( '/tmp/widget_rules_applied.log', "\n", FILE_APPEND );
				
				$unified_style_manager->collect_css_selector_styles(
					$selector,
					$converted_properties,
					$matching_widgets
				);
				$styles_applied += count( $matching_widgets );

				error_log( 'CSS PIPELINE DEBUG [WIDGET_CLASS]: Applied \'' . $selector . '\' to ' . count( $matching_widgets ) . ' widgets with class \'' . $target_class . '\'' );
			}
		}

		return $styles_applied;
	}

	private function convert_properties_to_atomic( array $properties, $property_conversion_service ): array {
		$converted_properties = [];
		
		foreach ( $properties as $property_data ) {
			$property = $property_data['property'];
			$value = $property_data['value'];
			$important = $property_data['important'] ?? false;
			
			$converted = $property_conversion_service->convert_property_to_v4_atomic( $property, $value );
			
			$converted_properties[] = [
				'property' => $property,
				'value' => $value,
				'original_property' => $property,
				'original_value' => $value,
				'important' => $important,
				'converted_property' => $converted,
			];
		}
		
		return $converted_properties;
	}

	private function find_widgets_with_specific_class( string $class_name, array $widgets ): array {
		$matching_widgets = [];
		$this->recursively_find_widgets_with_class( $class_name, $widgets, $matching_widgets );
		return $matching_widgets;
	}

	private function recursively_find_widgets_with_class( string $class_name, array $widgets, array &$matching_widgets ): void {
		foreach ( $widgets as $widget ) {
			$classes_string = $widget['attributes']['class'] ?? '';
			if ( ! empty( $classes_string ) ) {
				$classes_array = explode( ' ', $classes_string );
				if ( in_array( $class_name, $classes_array, true ) ) {
					$element_id = $widget['element_id'] ?? null;
					if ( $element_id ) {
						$matching_widgets[] = $element_id;
					}
				}
			}

			if ( ! empty( $widget['children'] ) ) {
				$this->recursively_find_widgets_with_class( $class_name, $widget['children'], $matching_widgets );
			}
		}
	}

	private function remove_processed_rules( array $css_rules, array $widget_rules ): array {
		$processed_selectors = array_column( $widget_rules, 'selector' );
		
		error_log( 'CSS PIPELINE DEBUG [WIDGET_CLASS]: remove_processed_rules - Total CSS rules: ' . count( $css_rules ) );
		error_log( 'CSS PIPELINE DEBUG [WIDGET_CLASS]: remove_processed_rules - Processed selectors: ' . count( $processed_selectors ) );
		
		$remaining_rules = [];
		$removed_count = 0;

		foreach ( $css_rules as $rule ) {
			$selector = $rule['selector'] ?? '';
			
			// FIXED: Remove ANY rule that was processed by Widget Class Processor
			// If we successfully applied it to widgets via widget-specific classes,
			// we should NOT let it be processed again as a global class
			// 
			// Example: .elementor-1140 .elementor-element.elementor-element-6d397c1
			// - Contains .elementor-1140 (page class)
			// - Contains .elementor-element-6d397c1 (widget class)
			// - We applied it to the widget → REMOVE IT
			// - Don't create a global class for it
			if ( in_array( $selector, $processed_selectors, true ) ) {
				// Remove this rule - it was processed by Widget Class Processor
				if ( strpos( $selector, 'elementor-element-6d397c1' ) !== false ) {
					error_log( 'CSS PIPELINE DEBUG [WIDGET_CLASS]: REMOVING TARGET: ' . $selector );
				}
				$removed_count++;
				continue;
			}
			
			$remaining_rules[] = $rule;
		}
		
		error_log( 'CSS PIPELINE DEBUG [WIDGET_CLASS]: Removed ' . $removed_count . ' rules, ' . count( $remaining_rules ) . ' remaining' );

		return $remaining_rules;
	}

	private function selector_contains_only_widget_classes( string $selector ): bool {
		// Extract all class names from the selector
		preg_match_all( '/\.([a-zA-Z0-9_-]+)/', $selector, $matches );
		
		if ( empty( $matches[1] ) ) {
			return false; // No classes found
		}
		
		$class_names = $matches[1];
		
		// Check if ALL classes are widget-specific
		foreach ( $class_names as $class_name ) {
			if ( ! $this->is_widget_class( $class_name ) ) {
				return false; // Found a non-widget class
			}
		}
		
		return true; // All classes are widget-specific
	}
}
