---
description: CSS Converter Atomic Widgets Mapping Rules
globs: ["**/*"]
alwaysApply: true
---

# CSS Converter â†” Atomic Widgets Mapping Rules

## ðŸš¨ CRITICAL PRINCIPLE: Reverse Engineering from Atomic V4

**NEVER create property mappers randomly or from scratch!**

All CSS property mappers MUST be derived from existing Elementor Atomic V4 transformers and prop types.

## Mapping Discovery Process

### 1. **ALWAYS Start with Atomic Widgets Analysis**

Before creating ANY property mapper, you MUST:

1. **Examine Atomic Elements**: `/plugins/elementor/modules/atomic-widgets/elements/`
   - Check `atomic-heading/`, `atomic-paragraph/`, `atomic-button/`, etc.
   - Look at their `define_props_schema()` methods
   - Identify what prop types they use

2. **Study Prop Types**: `/plugins/elementor/modules/atomic-widgets/prop-types/`
   - Find the relevant prop type (e.g., `size-prop-type.php`, `color-prop-type.php`)
   - Understand the expected `$$type` and `value` structure
   - Note validation rules and supported formats

3. **Check Style Definitions**: `/plugins/elementor/modules/atomic-widgets/styles/`
   - See how styles are applied and transformed
   - Understand the CSS output format

### 2. **Property Mapper Creation Rules**

#### âœ… CORRECT Process:
```php
// 1. First, examine the atomic widget
// Example: atomic-heading.php uses Size_Prop_Type for font-size

// 2. Check the prop type definition
// Example: size-prop-type.php expects:
// {
//   "$$type": "size",
//   "value": {
//     "size": 16,
//     "unit": "px"
//   }
// }

// 3. Create mapper that produces EXACTLY this structure
class Font_Size_Property_Mapper extends Property_Mapper_Base {
    public function map_to_v4_atomic( string $property, $value ): ?array {
        $parsed = $this->parse_size_value( $value );
        return $this->create_v4_property_with_type( 'font-size', 'size', $parsed );
    }
}
```

#### âŒ WRONG Process:
```php
// DON'T create mappers based on assumptions or CSS specs
class Random_Property_Mapper extends Property_Mapper_Base {
    public function map_to_v4_atomic( string $property, $value ): ?array {
        // This is WRONG - not based on atomic widgets!
        return $this->create_v4_property_with_type( $property, 'string', $value );
    }
}
```

## Required Research Steps

### For Each New Property Mapper:

1. **Find the Atomic Widget** that uses this property
   ```bash
   grep -r "font-size" /plugins/elementor/modules/atomic-widgets/elements/
   ```

2. **Identify the Prop Type**
   ```bash
   grep -r "Size_Prop_Type" /plugins/elementor/modules/atomic-widgets/elements/
   ```

3. **Study the Prop Type Implementation**
   ```php
   // Read: /plugins/elementor/modules/atomic-widgets/prop-types/size-prop-type.php
   // Understand the expected structure
   ```

4. **Check Existing Usage**
   ```bash
   grep -r "font-size" /plugins/elementor/modules/atomic-widgets/
   ```

5. **Test with Real Atomic Widget** before implementing

## Atomic Widget â†’ CSS Property Mapping

### Core Atomic Elements:

| Atomic Widget | File | Key Properties | Prop Types Used |
|---------------|------|----------------|-----------------|
| `e-heading` | `atomic-heading.php` | `title`, `tag`, `level` | `String_Prop_Type` |
| `e-paragraph` | `atomic-paragraph.php` | `paragraph` | `String_Prop_Type` |
| `e-button` | `atomic-button.php` | `text`, `link` | `String_Prop_Type`, `Link_Prop_Type` |
| `e-flexbox` | `flexbox.php` | Layout properties | Various layout types |

### Core Prop Types Reference:

| Prop Type | File | Expected Structure | CSS Properties |
|-----------|------|-------------------|----------------|
| `Size_Prop_Type` | `size-prop-type.php` | `{"$$type":"size","value":{"size":16,"unit":"px"}}` | `font-size`, `width`, `height`, etc. |
| `Color_Prop_Type` | `color-prop-type.php` | `{"$$type":"color","value":"#ffffff"}` | `color`, `background-color`, etc. |
| `Dimensions_Prop_Type` | `dimensions-prop-type.php` | `{"$$type":"dimensions","value":{"block-start":...}}` | `margin`, `padding`, etc. |
| `Background_Prop_Type` | `background-prop-type.php` | `{"$$type":"background","value":{"color":...}}` | `background` shorthand |
| `Border_Radius_Prop_Type` | `border-radius-prop-type.php` | `{"$$type":"border-radius","value":{"start-start":...}}` | `border-radius` |
| `Box_Shadow_Prop_Type` | `box-shadow-prop-type.php` | `{"$$type":"box-shadow","value":[...]}` | `box-shadow` |

## Implementation Validation

### Before Submitting Any Property Mapper:

1. **Verify Atomic Widget Usage**:
   ```php
   // Can you find this property being used in an atomic widget?
   // Does the atomic widget expect this exact $$type?
   ```

2. **Test Structure Compatibility**:
   ```php
   // Does your mapper output match the prop type's expected structure?
   // Will the atomic widget accept this format?
   ```

3. **Check Existing Patterns**:
   ```php
   // Are there similar properties already implemented?
   // Does your approach match the established patterns?
   ```

## Common Atomic Patterns

### Size Properties:
```php
// Based on Size_Prop_Type
return $this->create_v4_property_with_type( $property, 'size', [
    'size' => $numeric_value,
    'unit' => $unit
]);
```

### Color Properties:
```php
// Based on Color_Prop_Type  
return $this->create_v4_property_with_type( $property, 'color', $hex_color );
```

### Dimensions Properties:
```php
// Based on Dimensions_Prop_Type
return $this->create_v4_property_with_type( $property, 'dimensions', [
    'block-start' => ['$$type' => 'size', 'value' => $top],
    'inline-end' => ['$$type' => 'size', 'value' => $right],
    'block-end' => ['$$type' => 'size', 'value' => $bottom],
    'inline-start' => ['$$type' => 'size', 'value' => $left],
]);
```

## Enforcement Actions

### When Creating Property Mappers:

1. **MANDATORY**: Document which atomic widget uses this property
2. **MANDATORY**: Reference the specific prop type file
3. **MANDATORY**: Show the expected atomic structure in comments
4. **MANDATORY**: Test with actual atomic widget before implementation

### Code Review Checklist:

- [ ] Property mapper references specific atomic widget
- [ ] Output structure matches atomic prop type exactly
- [ ] Implementation follows existing atomic patterns
- [ ] No random or assumed property structures
- [ ] Tested with real atomic widget usage

## Examples of CORRECT Implementation

### Font Size Mapper (Based on atomic-heading.php + Size_Prop_Type):
```php
/**
 * Font Size Property Mapper
 * 
 * Based on: atomic-heading.php uses Size_Prop_Type for font-size
 * Prop Type: /prop-types/size-prop-type.php
 * Expected: {"$$type":"size","value":{"size":16,"unit":"px"}}
 */
class Font_Size_Property_Mapper extends Property_Mapper_Base {
    // Implementation matches Size_Prop_Type exactly
}
```

### Color Mapper (Based on atomic-heading.php + Color_Prop_Type):
```php
/**
 * Color Property Mapper
 * 
 * Based on: atomic-heading.php uses Color_Prop_Type for color
 * Prop Type: /prop-types/color-prop-type.php  
 * Expected: {"$$type":"color","value":"#ffffff"}
 */
class Color_Property_Mapper extends Property_Mapper_Base {
    // Implementation matches Color_Prop_Type exactly
}
```

## Special Cases & Exceptions

### Display Property Grid Values
- âœ… `display: grid` and `display: inline-grid` ARE supported (found in style-schema.php)
- âŒ Grid layout properties (`grid-template-columns`, etc.) are NOT supported yet
- ðŸ“‹ Grid layout properties added to FUTURE.md pending atomic widget support

### Properties Pending Atomic Widget Support
- Grid layout properties (grid-template-*, grid-gap, etc.)
- Advanced transforms (3D transforms, complex animations)
- Modern CSS features (container queries, CSS layers)

## Clean Code Principles for Atomic Widget Integration

### **Error Handling Best Practices**
- **No try/catch for business logic** - Use defensive programming
- **Return null for unsupported widgets** - Don't throw exceptions
- **Validate early and return fast** - Use guard clauses
- **Separate concerns** - Use dedicated validation and result builder classes

#### âœ… CORRECT Error Handling:
```php
class Atomic_Widget_Factory {
    public function create_widget( string $widget_type, array $html_element ): ?array {
        if ( ! $this->supports_widget_type( $widget_type ) ) {
            return null; // Early return, no exception
        }
        
        $schema = $this->get_props_schema_safely( $widget_type );
        if ( empty( $schema ) ) {
            return null; // Defensive programming
        }
        
        return $this->build_validated_widget( $widget_type, $html_element, $schema );
    }
    
    private function get_props_schema_safely( string $widget_type ): array {
        $class = $this->get_atomic_widget_class( $widget_type );
        if ( null === $class || ! method_exists( $class, 'define_props_schema' ) ) {
            return [];
        }
        
        return $class::define_props_schema();
    }
}
```

#### âŒ WRONG Error Handling:
```php
class Bad_Widget_Factory {
    public function create_widget( string $widget_type, array $html_element ): array {
        try {
            if ( ! $this->supports_widget_type( $widget_type ) ) {
                throw new \InvalidArgumentException( "Unsupported: {$widget_type}" );
            }
            
            return $this->build_widget( $widget_type, $html_element );
            
        } catch ( \Exception $e ) {
            error_log( "Widget creation failed: " . $e->getMessage() );
            return []; // Lost all context about what failed
        }
    }
}
```

### **Single Responsibility Principle**
- **Separate parsing from validation** - Different classes for different concerns
- **Use result builders** - Dedicated classes for building response structures
- **Extract statistics calculation** - Separate stats logic from conversion logic
- **Dedicated mappers** - One class per mapping concern

## Remember: ATOMIC WIDGETS ARE THE SOURCE OF TRUTH

Never guess. Never assume. Always derive from existing atomic v4 transformers.

The atomic widgets define the contract - we implement the reverse transformation.