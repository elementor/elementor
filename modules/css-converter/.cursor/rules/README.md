# CSS Converter Module - Cursor Rules

This directory contains cursor rules that govern AI behavior when working with the CSS Converter module. These rules are designed to prevent critical failures and ensure high-quality, user-focused development.

## ğŸ“‹ **Rule Categories**

### **ğŸš¨ Critical Thinking & Assumption Prevention**
- **`critical-thinking-protocol.mdc`** - Mandatory AI behavior rules to prevent assumption-based failures
- **`request-verification-protocol.mdc`** - Protocol for verifying user requests before implementation
- **`assumption-challenge-protocol.mdc`** - Forces constant challenging of assumptions and biases

### **ğŸ—ï¸ Architecture & Code Quality**
- **`atomic-widgets-mapping.mdc`** - Rules for integrating with Elementor's atomic widget system
- **`clean-code.mdc`** - Clean code standards and defensive programming practices
- **`property-mapper-validation.mdc`** - Validation rules for CSS property mappers

### **ğŸ§ª Development & Testing**
- **`debugging-validation.mdc`** - Debugging and validation protocols for PHP development
- **`folder-structure.mdc`** - Module folder structure and organization rules

## ğŸ¯ **Purpose**

These rules exist to prevent critical failures where the AI:
- Makes assumptions instead of asking clarifying questions
- Delivers solutions that don't match user requests
- Ignores explicit user requirements in favor of technical preferences
- Implements "best practices" instead of what was actually requested

## ğŸ“– **How to Use**

### **For AI Assistants**
1. **Read all rules** before responding to any user request
2. **Follow the protocols** outlined in each rule file
3. **Challenge your assumptions** using the provided frameworks
4. **Verify understanding** before implementing solutions

### **For Developers**
1. **Review rules** when working on the CSS Converter module
2. **Update rules** when new patterns or requirements emerge
3. **Reference protocols** when debugging or reviewing code
4. **Enforce standards** outlined in the architecture rules

## ğŸ”„ **Rule Priority**

### **Highest Priority (Always Follow)**
1. **Critical Thinking Protocol** - Prevent assumption-based failures
2. **Request Verification Protocol** - Ensure understanding before implementation
3. **Assumption Challenge Protocol** - Constantly question and verify

### **High Priority (Architecture & Quality)**
4. **Atomic Widgets Mapping** - Ensure proper integration with Elementor
5. **Clean Code Standards** - Maintain code quality and defensive programming
6. **Property Mapper Validation** - Ensure atomic widget compliance

### **Standard Priority (Development Support)**
7. **Debugging & Validation** - Support development and testing processes
8. **Folder Structure** - Maintain organization and cleanliness

## âš¡ **Quick Reference**

### **Before Every Response**
- [ ] Challenge your assumptions
- [ ] Verify user request understanding
- [ ] Ask clarifying questions
- [ ] Compare your approach to their request
- [ ] Flag any deviations and ask permission

### **Before Every Implementation**
- [ ] Study feasibility of user's exact request
- [ ] Document your assumptions explicitly
- [ ] Verify atomic widget compliance (if applicable)
- [ ] Follow clean code and defensive programming practices
- [ ] Test against ultra-strict validation requirements

### **Red Flags (Stop and Ask)**
- ğŸš© "That's not the best way to do it"
- ğŸš© User request differs from current implementation
- ğŸš© Multiple interpretations possible
- ğŸš© Making technical assumptions
- ğŸš© Implementing something not explicitly requested

## ğŸ“Š **Success Metrics**

These rules aim to achieve:
- **Zero assumption-based failures**
- **100% alignment with user requests**
- **Complete feasibility analysis** of requested approaches
- **No deviations without explicit permission**
- **High-quality, maintainable code** that follows atomic widget standards

## ğŸ”„ **Rule Evolution**

These rules are living documents that should be updated when:
- New failure patterns are identified
- User feedback reveals gaps in the protocols
- New architectural requirements emerge
- Better practices are discovered

---

**Remember: These rules exist to serve the user better by preventing critical failures and ensuring their actual requests are implemented, not what we think would be better.**
